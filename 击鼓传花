/*
学校联欢晚会的时候，为了使每一个同学都能参与进来，主持人常常会带着同学们玩击鼓传花的游戏。
游戏规则是这样的：n个同学坐着围成一个圆圈，指定一个同学手里拿着一束花，主持人在旁边背对着
大家开始击鼓，鼓声开始之后拿着花的同学开始传花，每个同学都可以把花传给自己左右的两个同学
中的一个（左右任意），当主持人停止击鼓时，传花停止，此时，正拿着花没传出去的那个同学就要
给大家表演一个节目。
聪明的小赛提出一个有趣的问题：有多少种不同的方法可以使得从小赛手里开始传的花，传了m次以后，
又回到小赛手里。对于传递的方法当且仅当这两种方法中，接到花的同学按接球顺序组成的序列是不
同的，才视作两种传花的方法不同。比如有3个同学1号、2号、3号，并假设小赛为1号，花传了3次回
到小赛手里的方式有1->2->3->1和1->3->2->1，共2种。
输入
输入共一行，有两个用空格隔开的整数n，m（3<=n<=30，1<=m<=30）
输出
输出共一行，有一个整数，表示符合题意的方法数
*/

#include<stdio.h>
//该数组用于存储传递次数为i，当前位置编号为j时的方法数
//用数组存储可减少递归次数，节省时间 
int data[31][31]; 
int n, m;
//传入两个参数，一个是传递的次数，一个是当前所在的位置编号 
int f(int times, int now) {
	now = (now+n) % n;
	//这种情况下的方法数已经计算过了 
	if(data[times][now] != -1) {
		return data[times][now]; 
	} 
	if(times == 0) {
		//当传递次数为0，且当前位置为起始位置，说明经过若干次传递，又传回起始位置
		if(now == 0) {  
			data[times][now] = 1; 
			return 1;
		} else {
			data[times][now] = 0;
			return 0;
		}
	} else {
		//当传递次数不为0时，花只能从左右两边传过来
		//将传递次数减一，位置变为当前位置的一前一后，二者相加即为结果
		data[times][now] = f(times-1, now+1) + f(times-1, now-1);
		return data[times][now];
	}
}

int main(void) {
	int i,j; 
	
	scanf("%d%d", &n, &m);
	//初始化 
	for(i = 0; i < 31; i++) {
		for(j = 0; j < 31; j++) {
			data[i][j] = -1;
		} 
	}
	
	printf("%d", f(m, 0));
	
	return 0; 
} 
